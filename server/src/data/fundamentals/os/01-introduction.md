# Chapter 1: Introduction to Operating Systems

## 1.1 What is an Operating System?
An Operating System (OS) is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs.

> **Analogy**: If the computer were a car, the OS would be the engine and the transmission, managing the power (CPU) and wheels (I/O) to get you (User) to your destination (Application Goal).

### Goals of an OS
1.  **Convenience**: Makes the computer system convenient to use.
2.  **Efficiency**: Allows resources to be used in an efficient manner.
3.  **Ability to Evolve**: Constructed in such a way as to permit the effective development, testing, and introduction of new system functions without interfering with service.

---

## 1.2 Computer System Architecture

### 1.2.1 Components
1.  **Hardware**: CPU, Memory, I/O Devices.
2.  **Operating System**: Controls and coordinates use of hardware.
3.  **Application Programs**: Compilers, Web Browsers, Games.
4.  **Users**: People, machines, other computers.

### 1.2.2 Interrupts
An interrupt is a signal sent to the CPU to stop its current activity and deal with some event.
*   **Hardware Interrupt**: Generated by devices (e.g., Disk finished reading, Keyboard press).
*   **Software Interrupt (Trap)**: Generated by code (e.g., System Call, Division by Zero error).
*   **Interrupt Vector**: A table of pointers to interrupt service routines.

---

## 1.3 Kernel Architecture
The Kernel is the core program of the OS that resides in memory at all times.

### 1.3.1 Monolithic Kernel
*   **Concept**: All OS services (File System, Drivers, Memory Manager) run in a single large kernel address space.
*   **Pros**: Very fast performance (function calls).
*   **Cons**: If one service crashes, the entire OS crashes. Hard to maintain.
*   **Examples**: Unix, Linux, MS-DOS.

### 1.3.2 Microkernel
*   **Concept**: Minimal kernel. Moves as much as possible to User Space (Servers).
*   **Pros**: More stable (service crash doesn't kill OS). easier to extend.
*   **Cons**: Performance overhead due to message passing between user/kernel modes.
*   **Examples**: Minix, QNX, Mach.

---

## 1.4 System Calls
The programming interface provided by the OS. When a user program needs a service (read file, create process), it uses a system call.

### 1.4.1 Dual Mode Operation
To protect the system, hardware supports two modes:
1.  **User Mode (Bit 1)**: Restricted. Normal apps run here. Cannot access hardware directly.
2.  **Kernel Mode (Bit 0)**: Privileged. OS runs here. Access to all instructions.

**Transition**:
*   User App calls `open()` -> **Trap** (Switch to Kernel Mode) -> OS Handler runs -> Return to User Mode.

### 1.4.2 Types of System Calls
*   **Process Control**: `fork()`, `exec()`, `exit()`, `wait()`.
*   **File Management**: `open()`, `read()`, `write()`, `close()`.
*   **Device Management**: `ioctl()`, `read()`, `write()`.
*   **Information Maintenance**: `getpid()`, `time()`.
*   **Communication**: `pipe()`, `shmget()`, `mmap()`.

---

## 1.5 Types of Operating Systems

### 1.5.1 Batch Operating System
*   **Mechanism**: Users submit jobs (cards) to operator. Operator batches similar jobs.
*   **Problem**: CPU is idle during I/O operations. (Speed mismatch between Electronic CPU and Mechanical I/O).

### 1.5.2 Multiprogramming (Batch) OS
*   **Goal**: Maximize CPU Utilization.
*   **Mechanism**: Keep multiple jobs in memory. When Job A waits for I/O, CPU switches to Job B.
*   **Requirement**: Memory Management, CPU Scheduling.

### 1.5.3 Time-Sharing (Multitasking) OS
*   **Goal**: Minimize Response Time.
*   **Mechanism**: CPU switches between jobs so frequently (milliseconds) that users can interact with each job while it is running.
*   **Concept**: Logic extension of multiprogramming.
*   **Time Quantum**: The slice of time allocated to each process.

### 1.5.4 Real-Time OS (RTOS)
*   **Hard Real-Time**: Critical deadlines. Missing a deadline is catastrophic (e.g., Pacemaker, Airbag). No Virtual Memory usually.
*   **Soft Real-Time**: Missing deadline is bad but not fatal (e.g., Video Streaming). Priority scheduling is key.

### 1.6 Distributed Systems
*   Collection of independent computers that appear to the user as a single coherent system.
*   **Tightly Coupled**: Shared memory (Parallel processors).
*   **Loosely Coupled**: Distributed memory (Networked computers).
